@inject IJSRuntime JS
@inherits ElementComponent
@implements IAsyncDisposable

<div @attributes="@AdditionalAttributes" id="@UUIDCode" class="@CssClass" loading="@_isLoading" collapsed="@_isCollapsed">
    <div class="header-wrapper">
        @Header

        <div class="arrow" tabindex="0" @onclick="ArrowClicked" @onkeydown="ArrowKeyPressed">

            @if (LoadingCurrent)
            {
                <span>LOADING</span>
                @* <Loader Width="40" Height="40"/>  *@
            }
            else if (Arrow != null)
            {
                @Arrow(IsCollapsed)
            }
            else
            {
                @if (IsCollapsed)
                {
                    <IconChevronDown Size="IconSizeEnum.Small"/>
                }
                else
                {
                    <IconChevronUp Size="IconSizeEnum.Small"/>
                }
            }
        </div>
    </div>

    <div class="content-wrapper" @ref="_refContentWrapper">
        @Content
    </div>
</div>

@code {

    [Parameter]
    public RenderFragment? Header { get; set; }

    [Parameter]
    public RenderFragment? Content { get; set; }

    [Parameter]
    public RenderFragment<bool>? Arrow { get; set; }

    [Parameter]
    public bool? Loading { get; set; }
    private bool LoadingCurrent => Loading ?? false;

    [Parameter]
    public bool? Collapsed { get; set; }
    private bool CollapsedCurrent => Collapsed ?? true;

    [Parameter]
    public EventCallback<bool> CollapsedChanged { get; set; }

    [Parameter]
    public Expression<Func<bool>>? CollapsedExpression { get; set; }

    private bool _intent;
    private bool _isLoading;
    private bool _isCollapsed;
    private bool? _isAnimating;
    private IJSObjectReference _module = null!;
    private DotNetObjectReference<Collapsible> _refDotNet = null!;
    private ElementReference _refContentWrapper;

    private bool IsCollapsed => _isAnimating ?? _isCollapsed;

    protected override void OnInitialized()
    {
        base.OnInitialized();
        _isCollapsed = CollapsedCurrent;
    }

    protected override async Task OnAfterFirstRenderAsync()
    {
        await base.OnAfterFirstRenderAsync();

        _refDotNet = DotNetObjectReference.Create(this);
        _module = await JS.InvokeAsync<IJSObjectReference>("import", JS.GetComponentPath(typeof(Collapsible)));

        await _module.InvokeVoidAsync("RegisterCollapsible", _isCollapsed, _refContentWrapper, _refDotNet, nameof(OnAnimationComplete));
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();

        // Loading is ongoing
        if (LoadingCurrent)
        {
            if (_isLoading) return;

            // Loading is starting
            _intent = CollapsedCurrent;
            _isCollapsed = true;
            _isLoading = true;
            _ = Animate(true);
            return;
        }

        // Loading is ending
        if (_isLoading && !LoadingCurrent)
        {
            _isLoading = false;
            // If intent and state is the same, ignore
            if (_intent == _isCollapsed) return;

            _isCollapsed = _intent;
            _ = Animate(_isCollapsed);
            return;
        }

        // If nothing has changed or we're already animating towards this state, ignore
        if (CollapsedCurrent == _isCollapsed || (_isAnimating.HasValue && _isAnimating.Value == CollapsedCurrent)) return;
        _ = Animate(CollapsedCurrent);
    }

    [JSInvokable]
    public async Task OnAnimationComplete(bool collapsed)
    {
        _isAnimating = null;
        _isCollapsed = collapsed;
        await InvokeAsync(StateHasChanged);
    }

    private async Task ArrowKeyPressed(KeyboardEventArgs args)
    {
        if (args.Code is " " or "Enter")
        {
            await Toggle();
        }
    }

    private async Task ArrowClicked()
    {
        await Toggle();
    }

    private async Task Toggle()
    {
        await Animate(!_isCollapsed);
        await CollapsedChanged.InvokeAsync(!_isCollapsed);
    }

    private async Task Animate(bool collapse)
    {
        _isAnimating = collapse;
        await _module.InvokeVoidAsync(collapse ? "AnimateCollapse" : "AnimateExpand", _refContentWrapper);
    }

    public async ValueTask DisposeAsync()
    {
        await _module.DisposeAsync();
        _refDotNet.Dispose();
    }

}
